options {
  JDK_VERSION = "1.8";
  STATIC=false;
}

PARSER_BEGIN(DelpParser)
package DeLP_GDPR.delp.parser;

import DeLP_GDPR.delp.syntax.DefeasibleLogicProgram;
import DeLP_GDPR.delp.syntax.DefeasibleRule;
import DeLP_GDPR.delp.syntax.DelpFact;
import DeLP_GDPR.delp.syntax.PriorityRule;
import DeLP_GDPR.delp.syntax.StrictRule;
import DeLP_GDPR.commons.Formula;
import DeLP_GDPR.commons.Parser;
import DeLP_GDPR.commons.ParserException;
import DeLP_GDPR.commons.Constant;
import DeLP_GDPR.commons.Predicate;
import DeLP_GDPR.commons.Variable;
import DeLP_GDPR.commons.Term;
import DeLP_GDPR.logics.fol.syntax.FolAtom;
import DeLP_GDPR.logics.fol.syntax.FolFormula;
import DeLP_GDPR.logics.fol.syntax.FolSignature;
import DeLP_GDPR.logics.fol.syntax.Negation;

import java.io.Reader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * This class implements a parser for defeasible logic programs.
 */
@SuppressWarnings("all")
public class DelpParser extends Parser<DefeasibleLogicProgram,Formula>{

    private FolSignature signature = new FolSignature();

    public DelpParser() { this(new StringReader("")); }

    public DefeasibleLogicProgram parseBeliefBase(Reader reader) throws ParserException{
        try {
            ReInit(reader);
            return this.Theory(this.signature);
        } catch(ParseException e) {
            throw new ParserException(e);
        }
    }

    public Formula parseFormula(Reader reader) throws ParserException{
        try {
            ReInit(reader);
            FolFormula fol = this.Formula(this.signature);
            validateFormula(fol);
            return fol;
        } catch(ParseException e) {
            throw new ParserException(e);
        }
    }

    private void validateFormula(FolFormula fol) throws ParseException {
        FolAtom atom = (FolAtom) fol.getAtoms().iterator().next();
        Predicate p = atom.getPredicate();
        if (signature.getPredicate(p.getName()) == null)
            throw new ParseException("Formula contains unknown predicate '" + p + "'");
        if (signature.getPredicate(p.getName()).getArity() != p.getArity())
            throw new ParseException("Formula contains predicate '" + p + "' with non-matching arity");
        for (Term t : atom.getArguments()) {
            if (t instanceof Constant &&
                    signature.getConstant(((Constant) t).get()) == null)
                throw new ParseException("Formula constains unknown constant '" + t + "'");
        }
    }

    public FolSignature getSignature(){
        return this.signature;
    }

    private Constant createConstant(String image, DefeasibleLogicProgram delp, FolSignature signature) throws ParseException {
        Constant constant = new Constant(image);
        if(delp != null && !signature.containsConstant(image))
            signature.add(constant);
        Predicate predicate = new Predicate(image);
        if(delp != null && !signature.containsPredicate(image))
            signature.add(predicate);
        if(signature.containsPredicate(image) && signature.getPredicate(image).getArity() != 0)
            throw new ParseException("Wrong arity of predicate as constant '" + image + "'");
        return constant;
    }
}

PARSER_END(DelpParser)

SKIP:  { " " | "\t" | "\n" | "\r" | <"%" (~["\n","\r"])* ("\n"|"\r")> }
TOKEN: {
    <NAME:   ["a"-"z","A"-"Z"] (["a"-"z","A"-"Z","_","-","0"-"9"])*>
|  <PRIORITY: ">" (<QUOTED> | <NAME> | <NUMBER>)*>
|   <QUOTED: "\"" (
                "\\" ~[]     //any escaped character
             |               //or
                ~["\"","\\"] //any character except quote or backslash
             )* "\"" >
}


void PriorityExpression(DefeasibleLogicProgram delp, FolSignature signature, Set<FolFormula> body) :
{
    DefeasibleRule defeasibleRule;
    PriorityRule priorityRule;
}
{
    defeasibleRule = DefeasibleRule(delp, signature) { body.add(defeasibleRule); }
    (
        "," defeasibleRule = DefeasibleRule(delp, signature) { body.add(defeasibleRule); }
    )* 
    ">" { priorityRule = PriorityRule(delp, signature, body); delp.add(priorityRule); }
}
void Expression(DefeasibleLogicProgram delp, FolSignature signature) :
{
    Set<FolFormula> body = new HashSet<FolFormula>();
    DefeasibleRule defeasibleRule;
    PriorityRule priorityRule;
}
{
    defeasibleRule = DefeasibleRule(delp, signature) { /* Handle DefeasibleRule */ }
    |
    priorityRule = PriorityExpression(delp, signature, body) { delp.add(priorityRule); }
}

Set<FolFormula> RuleBody(DefeasibleLogicProgram delp, FolSignature signature) :
{
    Set<FolFormula> body = new HashSet<FolFormula>();
    FolFormula b;
}
{
    b = Literal(delp, signature) { body.add(b); }
    (
        "," b = Literal(delp, signature) { body.add(b); }
    )*
    { return body; }
}

void Theory(FolSignature signature, DefeasibleLogicProgram delp) :
{
}
{
    ( Expression(delp, signature) )+ <EOF>
}

FolFormula Formula(FolSignature signature) :
{
    FolFormula lit;
}
{
    lit = Literal(null, signature) <EOF> { return lit; }
}

FolFormula Literal(DefeasibleLogicProgram delp, FolSignature signature) :
{
    FolAtom atom;
}
{
    atom = Atom(delp, signature) { return atom; }
    |
    "~" atom = Atom(delp, signature) { return new Negation(atom); }
}


FolAtom Atom(DefeasibleLogicProgram delp,FolSignature signature) :
{
    Token p;
    List<Term<?>> terms = new ArrayList<Term<?>>();
    Term<?> t;
}
{
    p=<NAME>
    (
        "(" t=Term(delp,signature) {terms.add(t);}
        ( "," t=Term(delp,signature) {terms.add(t);} )*
        ")"
    )?
    {
        // only add predicate to signature if parsing DeLP!
        Predicate predicate = new Predicate(p.image,terms.size());
        if(delp != null && !signature.containsPredicate(p.image))
            signature.add(predicate);
        if(signature.containsPredicate(p.image) && signature.getPredicate(p.image).getArity() != terms.size())
            throw new ParseException("Wrong arity of predicate '" + p.image + "'");
        return new FolAtom(predicate,terms);
    }
}

Term Term(DefeasibleLogicProgram delp,FolSignature signature) :
{
    Token t;
}
{
    t=<NAME>
    {
        if(Character.isUpperCase(t.image.charAt(0)))
            return new Variable(t.image);
        return createConstant(t.image, delp, signature);
    }
|
    t=<QUOTED>
    {
        // get rid of quotes:
        String text = t.image.substring(1, t.image.length() - 1);
        return createConstant(text, delp, signature);
    }
}